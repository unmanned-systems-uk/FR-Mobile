<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FR-Mobile: Implamentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FR-Mobile
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__implamentation.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implamentation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>/ Implementation Details</p>
<p>// <a class="el" href="class_s_d_card_manager.html" title="SD Card Manager implementing comprehensive file operations and data management.">SDCardManager</a> Implementation <a class="el" href="class_s_d_card_manager.html#aae6e52c99962cc46726da2ae1b8d6fff" title="Constructor.">SDCardManager::SDCardManager()</a> : basePath_("/sdcard") , initialized_(false) { }</p>
<p><a class="el" href="class_s_d_card_manager.html#ab57ea76fda6af453daffd968f1e2f023" title="Destructor - ensures proper cleanup and unmounting.">SDCardManager::~SDCardManager()</a> { if (initialized_) { unmountSDCard(); } }</p>
<p>bool <a class="el" href="class_s_d_card_manager.html#acfe3494064c3f0949ee260dc80a72fb1" title="Initialize and mount the SD card.">SDCardManager::initialize()</a> { printf("Initializing SD Card...\n");</p>
<p>if (!mountSDCard()) { printf("Failed to mount SD card\n"); return false; }</p>
<p>// Create necessary directories ensureDirectoryExists(basePath_ + "/data"); ensureDirectoryExists(basePath_ + "/logs"); ensureDirectoryExists(basePath_ + "/assert");</p>
<p>initialized_ = true; printf("SD Card initialized successfully\n"); return true; }</p>
<p>bool <a class="el" href="class_s_d_card_manager.html#a6ab77104e2009ea904cb1ca5e014a8dc" title="Write probe request data to specified file.">SDCardManager::writeData(const ProbeRequest&amp; data, const std::string&amp; filename)</a> { if (!initialized_) { return false; }</p>
<p>std::string fullPath = basePath_ + "/" + sanitizeFilename(filename);</p>
<p>try { std::ofstream file(fullPath, std::ios::app); if (!file.is_open()) { printf("Failed to open file: %s\n", fullPath.c_str()); return false; }</p>
<p>// Write CSV format file &lt;&lt; data.dataType &lt;&lt; "," &lt;&lt; data.timestamp &lt;&lt; "," &lt;&lt; data.source &lt;&lt; "," &lt;&lt; data.rssi &lt;&lt; "," &lt;&lt; data.packetLength &lt;&lt; "," &lt;&lt; data.macAddress &lt;&lt; "," &lt;&lt; data.payload &lt;&lt; "\n";</p>
<p>file.close(); return true;</p>
<p>} catch (const std::exception&amp; e) { printf("Error writing to SD card: %s\n", e.what()); return false; } }</p>
<p>bool <a class="el" href="class_s_d_card_manager.html#af4841369a577a377f6cd95022675b1c4" title="Write asset information to dedicated file.">SDCardManager::writeAssetData(const AssetInfo&amp; data)</a> { if (!initialized_) { return false; }</p>
<p>std::string filename = basePath_ + "/assert/assert_" + data.timeStamp + ".csv"; filename = sanitizeFilename(filename);</p>
<p>try { std::ofstream file(filename); if (!file.is_open()) { return false; }</p>
<p>// Write header file &lt;&lt; "assetId,locationName,forestName,latitude,longitude," &lt;&lt; "remainingBatteryCapacity,stateOfCharge,runtimeToEmpty," &lt;&lt; "batteryVoltage,batteryCurrent,SDCardCapacity,timeStamp\n";</p>
<p>// Write data file &lt;&lt; data.assetId &lt;&lt; "," &lt;&lt; data.locationName &lt;&lt; "," &lt;&lt; data.forestName &lt;&lt; "," &lt;&lt; data.latitude &lt;&lt; "," &lt;&lt; data.longitude &lt;&lt; "," &lt;&lt; data.remainingBatteryCapacity &lt;&lt; "," &lt;&lt; data.stateOfCharge &lt;&lt; "," &lt;&lt; data.runtimeToEmpty &lt;&lt; "," &lt;&lt; data.batteryVoltage &lt;&lt; "," &lt;&lt; data.batteryCurrent &lt;&lt; "," &lt;&lt; data.sdCardCapacity &lt;&lt; "," &lt;&lt; data.timeStamp &lt;&lt; "\n";</p>
<p>file.close(); return true;</p>
<p>} catch (const std::exception&amp; e) { printf("Error writing asset data: %s\n", e.what()); return false; } }</p>
<p>std::vector&lt;std::string&gt; <a class="el" href="class_s_d_card_manager.html#af43ef1a9bf7c1b018e4a5fb6749eb4bf" title="Read all lines from specified file.">SDCardManager::readFile(const std::string&amp; filename)</a> { std::vector&lt;std::string&gt; lines;</p>
<p>if (!initialized_) { return lines; }</p>
<p>std::string fullPath = basePath_ + "/" + sanitizeFilename(filename);</p>
<p>try { std::ifstream file(fullPath); if (!file.is_open()) { return lines; }</p>
<p>std::string line; while (std::getline(file, line)) { lines.push_back(line); }</p>
<p>file.close();</p>
<p>} catch (const std::exception&amp; e) { printf("Error reading file: %s\n", e.what()); }</p>
<p>return lines; }</p>
<p>bool <a class="el" href="class_s_d_card_manager.html#a0904bd3d1f9f31b78491050569548b50" title="Check if specified file exists.">SDCardManager::fileExists(const std::string&amp; filename)</a> { std::string fullPath = basePath_ + "/" + sanitizeFilename(filename); return std::filesystem::exists(fullPath); }</p>
<p>size_t <a class="el" href="class_s_d_card_manager.html#a28d799290f6cc9da4fde5cbdc0e0c86b" title="Get size of specified file.">SDCardManager::getFileSize(const std::string&amp; filename)</a> { std::string fullPath = basePath_ + "/" + sanitizeFilename(filename);</p>
<p>try { return std::filesystem::file_size(fullPath); } catch (const std::exception&amp; e) { return 0; } }</p>
<p>float <a class="el" href="class_s_d_card_manager.html#a01ebab598264e675f413c65c7d471d91" title="Get remaining storage capacity as percentage.">SDCardManager::getRemainingCapacityPercent()</a> { try { auto space = std::filesystem::space(basePath_); float used = static_cast&lt;float&gt;(space.capacity - space.available); float total = static_cast&lt;float&gt;(space.capacity); return 100.0f * (1.0f - (used / total)); } catch (const std::exception&amp; e) { return 0.0f; } }</p>
<p>// <a class="el" href="class_cellular_manager.html" title="Cellular Manager implementing comprehensive network communication.">CellularManager</a> Implementation <a class="el" href="class_cellular_manager.html#a64cd463ed759ad563d3f0bd9d3028095" title="Constructor.">CellularManager::CellularManager()</a> : connected_(false) , serialHandle_(nullptr) , apiUrl_("https://uk-610246-forestryresearchapi-app-dev-01.azurewebsites.net/api/DeviceData") { }</p>
<p><a class="el" href="class_cellular_manager.html#ac22f2d9e34917aa6039d273e643bc699" title="Destructor - ensures proper cleanup and disconnection.">CellularManager::~CellularManager()</a> { disconnect(); }</p>
<p>bool <a class="el" href="class_cellular_manager.html#ac903c33125d1da07d1bedc7fe74cdca4" title="Connect to cellular network with full initialization.">CellularManager::connect()</a> { printf("Connecting to cellular network...\n");</p>
<p>try { // Initialize serial communication #ifdef ESP32_PLATFORM // Serial2.begin(115200, SERIAL_8N1, RX_PIN, TX_PIN); // Serial2.setRxBufferSize(1024); #endif</p>
<p>// Test basic AT communication if (!sendATCommand("AT", "OK", 10)) { printf("Failed basic AT communication\n"); return false; }</p>
<p>// Check SIM status if (!sendATCommand("AT+CPIN?", "+CPIN: READY", 10)) { printf("SIM not ready\n"); return false; }</p>
<p>// Check network registration if (!sendATCommand("AT+CREG?", "+CREG: 0,1", 10)) { printf("Not registered to network\n"); return false; }</p>
<p>// Configure APN if (!configureAPN()) { printf("Failed to configure APN\n"); return false; }</p>
<p>// Activate PDP context if (!activatePDPContext()) { printf("Failed to activate PDP context\n"); return false; }</p>
<p>connected_ = true; printf("Cellular connection established\n"); return true;</p>
<p>} catch (const std::exception&amp; e) { printf("Cellular connection failed: %s\n", e.what()); return false; } }</p>
<p>bool <a class="el" href="class_cellular_manager.html#aabd59f33e3c4d44d8e05dc32b5d56751" title="Send data via HTTP POST to configured endpoint.">CellularManager::sendData(const std::string&amp; data)</a> { if (!connected_) { printf("Not connected to cellular network\n"); return false; }</p>
<p>return sendHTTPData(data); }</p>
<p>std::string <a class="el" href="class_cellular_manager.html#adc96fcfbc4531bde2ba1043bbfd6f378" title="Get current network time from cellular provider.">CellularManager::getNetworkTime()</a> { if (!sendATCommand("AT", "OK", 10)) { return "Error: Unable to fetch network time"; }</p>
<p>std::string response;</p>
<p>#ifdef ESP32_PLATFORM // Send CCLK command and parse response // Serial2.println("AT+CCLK?"); // // auto startTime = std::chrono::steady_clock::now(); // const auto timeout = std::chrono::seconds(5); // // while (std::chrono::steady_clock::now() - startTime &lt; timeout) { // if (Serial2.available()) { // char c = Serial2.read(); // response += c; // <br  />
 // if (response.find("+CCLK:") != std::string::npos &amp;&amp; // response.find("OK") != std::string::npos) { // break; // } // } // } #endif</p>
<p>// Parse time from response size_t timeStart = response.find("+CCLK: \"") + 8; size_t timeEnd = response.find("\"", timeStart);</p>
<p>if (timeStart != std::string::npos &amp;&amp; timeEnd != std::string::npos) { return response.substr(timeStart, timeEnd - timeStart); }</p>
<p>return "Error: Unable to fetch network time"; }</p>
<p>bool CellularManager::sendATCommand(const std::string&amp; command, 
                                   const std::string&amp; expectedResponse, 
                                   int maxAttempts, int timeoutMs) { for (int attempt = 0; attempt &lt; maxAttempts; ++attempt) { #ifdef ESP32_PLATFORM // Serial2.println(command.c_str()); #endif</p>
<p>auto startTime = std::chrono::steady_clock::now(); auto timeout = std::chrono::milliseconds(timeoutMs); std::string response;</p>
<p>while (std::chrono::steady_clock::now() - startTime &lt; timeout) { #ifdef ESP32_PLATFORM // if (Serial2.available()) { // char c = Serial2.read(); // response += c; // } #endif</p>
<p>if (response.find(expectedResponse) != std::string::npos) { printf("AT Response: %s\n", response.c_str()); return true; } }</p>
<p>printf("AT Command failed (attempt %d): %s\n", attempt + 1, response.c_str()); }</p>
<p>return false; }</p>
<p>// <a class="el" href="class_r_t_c_time_manager.html" title="RTC Time Manager implementing comprehensive time management.">RTCTimeManager</a> Implementation <a class="el" href="class_r_t_c_time_manager.html#a0f47edf7e2b9fd457ffad05698315e55" title="Constructor.">RTCTimeManager::RTCTimeManager()</a> : rtcHandle_(nullptr) , initialized_(false) { }</p>
<p>std::string <a class="el" href="class_r_t_c_time_manager.html#a375c44c208916c4eba627a8646ba6d10" title="Get current date and time as ISO 8601 string.">RTCTimeManager::getCurrentDateTime()</a> { if (!initialized_) { return ""; }</p>
<p>auto now = std::chrono::system_clock::now(); auto time_t = std::chrono::system_clock::to_time_t(now); auto tm = *std::gmtime(&amp;time_t);</p>
<p>char buffer[30]; std::strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%SZ", &amp;tm);</p>
<p>return std::string(buffer); }</p>
<p>bool <a class="el" href="class_r_t_c_time_manager.html#a2866ea935a808c7be6e5f3d445f0d876" title="Set RTC time from network time string.">RTCTimeManager::setTimeFromNetwork(const std::string&amp; networkTime)</a> { printf("Setting RTC from network time: %s\n", networkTime.c_str());</p>
<p>if (!isValidTime(networkTime)) { printf("Invalid network time format\n"); return false; }</p>
<p>try { <a class="el" href="struct_time_components.html" title="Time components structure for date/time manipulation.">TimeComponents</a> time = parseNetworkTime(networkTime);</p>
<p>#ifdef ESP32_PLATFORM // Platform-specific RTC setting code would go here // DS1307.setTime(timeArray); #endif</p>
<p>printf("RTC time updated successfully\n"); return true;</p>
<p>} catch (const std::exception&amp; e) { printf("Failed to set RTC time: %s\n", e.what()); return false; } }</p>
<p>bool <a class="el" href="class_r_t_c_time_manager.html#ad5009618a016999e625a5aba0815561d" title="Validate network time string format and content.">RTCTimeManager::isValidTime(const std::string&amp; timeStr)</a> { // Check format: "YY/MM/DD,HH:MM:SS+ZZ" if (timeStr.length() != 20) { return false; }</p>
<p>// Check delimiters return (timeStr[2] == '/' &amp;&amp; timeStr[5] == '/' &amp;&amp; timeStr[8] == ',' &amp;&amp; timeStr[11] == ':' &amp;&amp; timeStr[14] == ':' &amp;&amp; timeStr[17] == '+'); }</p>
<p>uint64_t <a class="el" href="class_r_t_c_time_manager.html#afb1e2fef62322a3752ba879d2bd10fa4" title="Calculate sleep duration for night time power saving.">RTCTimeManager::getNightSleepDuration(const std::string&amp; currentTime)</a> { if (!isValidTime(currentTime)) { return 0; }</p>
<p><a class="el" href="struct_time_components.html" title="Time components structure for date/time manipulation.">TimeComponents</a> time = parseNetworkTime(currentTime);</p>
<p>// Check if it's night time (22:00 - 06:00) if (time.hour &gt;= 22 || time.hour &lt;= 6) { return calculateSleepDuration(time.hour, time.minute); }</p>
<p>return 0; // Not night time }</p>
<p>// <a class="el" href="class_power_manager.html" title="Power Manager implementing comprehensive power control and optimization.">PowerManager</a> Implementation <br  />
 <a class="el" href="class_power_manager.html#ac042154201d1c37f6bd5cfc0441849b9" title="Constructor.">PowerManager::PowerManager()</a> : initialized_(false) , lastWakeupCause_(WakeupCause::UNKNOWN) { }</p>
<p>bool <a class="el" href="class_power_manager.html#a217939b880543bfff917203a06d45258" title="Initialize power management system.">PowerManager::initialize()</a> { printf("Initializing Power Management\n");</p>
<p>// Configure watchdog configureWatchdog(300000); // 5 minutes</p>
<p>// Analyze wakeup cause lastWakeupCause_ = getWakeupCause(); printf("Wakeup cause: %s\n", getWakeupCauseString().c_str()); printf("Reset reason: %s\n", getResetReasonString().c_str());</p>
<p>initialized_ = true; return true; }</p>
<p>void <a class="el" href="class_power_manager.html#a416206aeab4fad278771c33df90d55aa" title="Enable peripheral power supplies.">PowerManager::enablePeripherals()</a> { printf("Enabling 5V peripheral power\n"); enable5V(); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); }</p>
<p>void <a class="el" href="class_power_manager.html#a84eca8b42dcd28a7211ddd33e4057d01" title="Disable peripheral power supplies for power saving.">PowerManager::disablePeripherals()</a> { printf("Disabling 5V peripheral power\n"); disable5V(); }</p>
<p>void <a class="el" href="class_power_manager.html#a1a7bb8e40ab19a380bb6a3930c2deb75" title="Enter deep sleep mode for specified duration.">PowerManager::enterSleep(uint64_t sleepTimeUs)</a> { printf("Entering deep sleep for %llu seconds\n", sleepTimeUs / 1000000);</p>
<p>disablePeripherals(); configureWakeup(sleepTimeUs);</p>
<p>#ifdef ESP32_PLATFORM // esp_deep_sleep_start(); #endif }</p>
<p><a class="el" href="power__manager_8h.html#a4145a5bb637b4b78d0a7926f830b2f44" title="Deep sleep wakeup cause enumeration.">WakeupCause</a> <a class="el" href="class_power_manager.html#ac9f7272f6409e1da2271e4c3b692000e" title="Get the cause of the last wakeup event.">PowerManager::getWakeupCause()</a> { #ifdef ESP32_PLATFORM // esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause(); // switch (cause) { // case ESP_SLEEP_WAKEUP_TIMER: // return <a class="el" href="power__manager_8h.html#a4145a5bb637b4b78d0a7926f830b2f44ab127d163c55a6603f3a37ce3a642c36d" title="Timer wakeup.">WakeupCause::TIMER</a>; // case ESP_SLEEP_WAKEUP_EXT0: // case ESP_SLEEP_WAKEUP_EXT1: // return <a class="el" href="power__manager_8h.html#a4145a5bb637b4b78d0a7926f830b2f44a3932d629fb5e2be9d09b3a4485b3cc9d">WakeupCause::EXTERNAL</a>; // default: // return <a class="el" href="power__manager_8h.html#a4145a5bb637b4b78d0a7926f830b2f44a696b031073e74bf2cb98e5ef201d4aa3" title="Unknown wakeup cause.">WakeupCause::UNKNOWN</a>; // } #endif</p>
<p>return <a class="el" href="power__manager_8h.html#a4145a5bb637b4b78d0a7926f830b2f44a696b031073e74bf2cb98e5ef201d4aa3" title="Unknown wakeup cause.">WakeupCause::UNKNOWN</a>; </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
